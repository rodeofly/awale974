// Generated by CoffeeScript 1.10.0
(function() {
  var $graines, Awale, clone, debug, unique_id,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  unique_id = 0;

  debug = false;

  $graines = 4;

  clone = function(obj) {
    var key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  Awale = (function() {
    function Awale() {
      var i, l, ref;
      ref = [unique_id++, 0, 1, 1, 1, {}], this.id = ref[0], this.player = ref[1], this.adversaire = ref[2], this.pointeur = ref[3], this.graphique = ref[4], this.trous = ref[5];
      for (i = l = 1; l <= 12; i = ++l) {
        this.trous[i] = 0;
      }
      this.camps = {
        0: [1, 2, 3, 4, 5, 6],
        1: [7, 8, 9, 10, 11, 12]
      };
      this.score = {
        0: 0,
        1: 0
      };
      this.initialiser = function() {
        var j, m, results;
        results = [];
        for (i = m = 1; m <= 6; i = ++m) {
          this.pointeur = i;
          results.push((function() {
            var n, ref1, results1;
            results1 = [];
            for (j = n = 1, ref1 = $graines; 1 <= ref1 ? n <= ref1 : n >= ref1; j = 1 <= ref1 ? ++n : --n) {
              results1.push(this.depose_une_graine());
            }
            return results1;
          }).call(this));
        }
        return results;
      };
      this.joueur_suivant = function() {
        var ref1;
        ref1 = [this.adversaire, this.player], this.player = ref1[0], this.adversaire = ref1[1];
        if (this.graphique) {
          return $("#awalé_" + this.id + " .camp").toggleClass("selected");
        }
      };
      this.trou_suivant = function() {
        return this.pointeur = this.pointeur % 12 + 1;
      };
      this.trou_precedent = function() {
        return this.pointeur = (this.pointeur - 1) % 12;
      };
      this.total_graines = function(joueur, g) {
        var len, m, ref1;
        if (g == null) {
          g = 0;
        }
        ref1 = this.camps[joueur];
        for (m = 0, len = ref1.length; m < len; m++) {
          i = ref1[m];
          g += this.trous[i];
        }
        return g;
      };
      this.prendre_les_graines = function() {
        var main, ref1;
        if (debug) {
          console.log("$ @prendre_les_graines : en ce moment il y a " + this.trous[this.pointeur] + " graine(s) dans le trou " + this.pointeur);
        }
        ref1 = [this.trous[this.pointeur], 0], main = ref1[0], this.trous[this.pointeur] = ref1[1];
        if (this.graphique) {
          $("#" + this.pointeur).empty();
        }
        return main;
      };
      this.depose_une_graine = function() {
        this.trous[this.pointeur] += 1;
        if (this.graphique) {
          $("#" + this.pointeur).append("<div class='graine'></div>");
          return $("#" + this.pointeur + " .graine").each(function() {
            var rand;
            rand = function() {
              return 10 + Math.floor(Math.random() * 45);
            };
            return $(this).css({
              top: (rand()) + "%",
              left: (rand()) + "%",
              transform: "rotate(" + (3 * rand()) + "deg)"
            });
          });
        }
      };
      this.nourrirAdversaire = function() {
        return this.pointeur + this.trous[this.pointeur] > 6 * (this.player + 1);
      };
      this.prenable = function(origine, gain_virtuel) {
        var ref1, ref2;
        if (origine == null) {
          origine = this.pointeur;
        }
        if (gain_virtuel == null) {
          gain_virtuel = 0;
        }
        while (((ref1 = this.trous[this.pointeur]) === 2 || ref1 === 3) && (ref2 = this.pointeur, indexOf.call(this.camps[this.adversaire], ref2) >= 0)) {
          gain_virtuel += this.trous[this.pointeur];
          this.trou_precedent();
        }
        this.pointeur = origine;
        return (gain_virtuel > 0) && (gain_virtuel !== this.total_graines(this.adversaire));
      };
      this.prendre = function() {
        var ref1, ref2, results;
        if (debug) {
          console.log("$ @prendre() : il y a prise !");
        }
        results = [];
        while (((ref1 = this.trous[this.pointeur]) === 2 || ref1 === 3) && (ref2 = this.pointeur, indexOf.call(this.camps[this.adversaire], ref2) >= 0)) {
          this.score[this.player] += this.trous[this.pointeur];
          this.prendre_les_graines();
          if (this.graphique) {
            $("#score" + this.player).html(this.score[this.player]);
          }
          results.push(this.trou_precedent());
        }
        return results;
      };
      this.reprendre_ses_graines = function() {
        var len, len1, m, n, player, ref1, ref2, results, trou;
        ref1 = [0, 1];
        results = [];
        for (m = 0, len = ref1.length; m < len; m++) {
          player = ref1[m];
          ref2 = this.camps[player];
          for (n = 0, len1 = ref2.length; n < len1; n++) {
            trou = ref2[n];
            this.pointeur = trou;
            this.score[player] += this.trous[this.pointeur];
            this.prendre_les_graines();
          }
          if (this.graphique) {
            results.push($("#score" + player).html(this.score[player]));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      this.fin_de_jeu = function() {
        var config1, config2, len, m, ref1, the_end, trou;
        the_end = true;
        config1 = (this.total_graines(this.player) === 1) && (this.total_graines(this.adversaire) === 1) && ((this.trous[1] === 1) && (this.trous[7] === 1));
        config2 = (this.total_graines(this.player) === 2) && (this.total_graines(this.adversaire) === 2) && ((this.trous[1] === 1) && (this.trous[2] === 1) && (this.trous[7] === 1) && (this.trous[8] === 1));
        if (config1 || config2) {
          return the_end;
        } else {
          ref1 = this.camps[this.player];
          for (m = 0, len = ref1.length; m < len; m++) {
            trou = ref1[m];
            if (this.jouable(trou)) {
              the_end = !the_end;
            }
            if (!the_end) {
              break;
            }
          }
        }
        return the_end;
      };
      this.jouable = function(pointeur) {
        var ref1;
        this.pointeur = pointeur;
        if (debug) {
          console.log("$ @jouable(" + this.pointeur + ") : Ce coup est-il jouable ?");
        }
        if ((ref1 = this.pointeur, indexOf.call(this.camps[this.player], ref1) >= 0) && (this.trous[this.pointeur] > 0)) {
          console.log("a : " + (this.total_graines(this.adversaire)));
          switch (this.total_graines(this.adversaire)) {
            case 0:
              console.log(this.nourrirAdversaire());
              return this.nourrirAdversaire();
            default:
              return true;
          }
        } else {
          return false;
        }
      };
    }

    Awale.prototype.jouer = function(pointeur) {
      var main, origine;
      this.pointeur = pointeur;
      if (debug) {
        console.log("joueur" + this.player + " veut jouer le trou " + this.pointeur + " dans lequel il y a " + this.trous[this.pointeur] + " graine(s)");
      }
      if (this.jouable(this.pointeur)) {
        origine = this.pointeur;
        main = this.prendre_les_graines();
        if (debug) {
          console.log("ok, c'est jouable ! le pointeur est en " + this.pointeur + ", je prend " + main + " graine(s) dans ma main.");
        }
        while (main > 0) {
          this.trou_suivant();
          if (this.pointeur !== origine) {
            this.depose_une_graine();
            main -= 1;
          }
        }
        if (this.prenable()) {
          this.prendre();
        }
        this.joueur_suivant();
        if (this.fin_de_jeu()) {
          if (this.graphique) {
            alert("jeu terminé !");
          }
          return this.reprendre_ses_graines();
        }
      } else {
        return console.log("argh, ce n'est pas jouable !");
      }
    };

    Awale.prototype.to_html = function() {
      var $awalé, j, l, m, ref, trou;
      $awalé = $("<div><div id='awalé_" + this.id + "' class='awalé'><div id='camp0' class='camp'></div><div id='camp1' class='camp'></div></div></div>");
      for (trou = l = 1; l <= 12; trou = ++l) {
        $awalé.find("#camp" + (trou < 7 ? 0 : 1)).append("<div id='" + trou + "' class='trou'>");
        this.pointeur = trou;
        for (j = m = 0, ref = this.trous[j] - 1; 0 <= ref ? m <= ref : m >= ref; j = 0 <= ref ? ++m : --m) {
          this.depose_une_graine();
        }
      }
      return $awalé.html();
    };

    return Awale;

  })();

  $(function() {
    var AIlevel, awale, first_dblclick;
    awale = new Awale();
    $("#game").append(awale.to_html());
    awale.initialiser();
    first_dblclick = true;
    $(".trou").on("click", function() {
      var t;
      t = parseInt($(this).attr("id"));
      $(".trou").removeClass("selected");
      $(this).addClass("selected");
      return $(this).append($("#info").html(awale.trous[t]).show());
    });
    $(".trou").on("dblclick", function() {
      var ref, t;
      t = parseInt($(this).attr("id"));
      if (first_dblclick) {
        ref = indexOf.call([1, 2, 3, 4, 5, 6], t) >= 0 ? [0, 1] : [1, 0], awale.player = ref[0], awale.adversaire = ref[1];
        $("#awalé_" + awale.id + " #camp" + awale.player).addClass("selected");
        first_dblclick = false;
      }
      $("body").append($("#info").hide());
      return awale.jouer(t);
    });
    AIlevel = 1;
    $("input[name=AIlevel]").on("click", function() {
      return AIlevel = parseInt($(this).val());
    });
    return $("#ordi").on("click", function() {
      var awales, best, delta, i, j, k, l, len, len1, len2, len3, m, max, n, o, ref, ref1, ref2, ref3, ref4, t;
      if (first_dblclick) {
        t = Math.floor(Math.random() * 2);
        ref = indexOf.call([1, 2, 3, 4, 5, 6], t) >= 0 ? [0, 1] : [1, 0], awale.player = ref[0], awale.adversaire = ref[1];
        $("#awalé_" + awale.id + " #camp" + awale.player).addClass("selected");
        first_dblclick = false;
      }
      max = -50;
      best = -1;
      ref1 = awale.camps[awale.player];
      for (l = 0, len = ref1.length; l < len; l++) {
        i = ref1[l];
        if (awale.jouable(i)) {
          best = i;
          break;
        }
      }
      if (best === -1) {
        alert("???");
      }
      awales = {};
      ref2 = awale.camps[awale.player];
      for (m = 0, len1 = ref2.length; m < len1; m++) {
        i = ref2[m];
        awales["" + i] = clone(awale);
        awales["" + i].graphique = false;
        if (awales["" + i].jouable(i)) {
          awales["" + i].jouer(i);
          delta = awales["" + i].score[awale.player] - awales["" + i].score[awale.adversaire];
          if (delta > max) {
            max = delta;
            best = parseInt(i);
          }
          if (AIlevel > 2) {
            console.log("AI:level 2, max was " + max + " with trou " + best);
            ref3 = awale.camps[awale.adversaire];
            for (n = 0, len2 = ref3.length; n < len2; n++) {
              j = ref3[n];
              awales[i + "-" + j] = clone(awales["" + i]);
              if (awales[i + "-" + j].jouable(j)) {
                awales[i + "-" + j].jouer(j);
                delta = awales[i + "-" + j].score[awale.player] - awales[i + "-" + j].score[awale.adversaire];
                if (delta > max) {
                  max = delta;
                  best = parseInt(i);
                }
                if (AIlevel === 3) {
                  console.log("AI:level 3, max was " + max + " with trou " + best);
                  ref4 = awale.camps[awale.player];
                  for (o = 0, len3 = ref4.length; o < len3; o++) {
                    k = ref4[o];
                    awales[i + "-" + j + "-" + k] = clone(awales[i + "-" + j]);
                    if (awales[i + "-" + j + "-" + k].jouable(k)) {
                      awales[i + "-" + j + "-" + k].jouer(k);
                      delta = awales[i + "-" + j + "-" + k].score[awale.player] - awales[i + "-" + j + "-" + k].score[awale.adversaire];
                      if (delta > max) {
                        max = delta;
                        best = parseInt(i);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      console.log("Je vais t'éclater en jouant le trou " + best);
      return awale.jouer(best);
    });
  });

}).call(this);
