// Generated by CoffeeScript 1.9.0
(function() {
  var $graines, Awale, clone, debug, unique_id,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  unique_id = 0;

  debug = false;

  $graines = 4;

  clone = function(obj) {
    var key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  Awale = (function() {
    function Awale() {
      var i, _i, _ref;
      _ref = [unique_id++, 0, 1, 1, 1, {}], this.id = _ref[0], this.player = _ref[1], this.adversaire = _ref[2], this.pointeur = _ref[3], this.graphique = _ref[4], this.trous = _ref[5];
      for (i = _i = 1; _i <= 12; i = ++_i) {
        this.trous[i] = 0;
      }
      this.camps = {
        0: [1, 2, 3, 4, 5, 6],
        1: [7, 8, 9, 10, 11, 12]
      };
      this.score = {
        0: 0,
        1: 0
      };
      this.initialiser = function() {
        var j, _j, _results;
        _results = [];
        for (i = _j = 1; _j <= 12; i = ++_j) {
          this.pointeur = i;
          _results.push((function() {
            var _k, _results1;
            _results1 = [];
            for (j = _k = 1; 1 <= $graines ? _k <= $graines : _k >= $graines; j = 1 <= $graines ? ++_k : --_k) {
              _results1.push(this.depose_une_graine());
            }
            return _results1;
          }).call(this));
        }
        return _results;
      };
      this.joueur_suivant = function() {
        var _ref1;
        _ref1 = [this.adversaire, this.player], this.player = _ref1[0], this.adversaire = _ref1[1];
        if (this.graphique) {
          return $("#awalé_" + this.id + " .camp").toggleClass("selected");
        }
      };
      this.trou_suivant = function() {
        return this.pointeur = this.pointeur % 12 + 1;
      };
      this.trou_precedent = function() {
        return this.pointeur = (this.pointeur - 1) % 12;
      };
      this.total_graines = function(joueur, g) {
        var _j, _len, _ref1;
        if (g == null) {
          g = 0;
        }
        _ref1 = this.camps[joueur];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          i = _ref1[_j];
          g += this.trous[i];
        }
        return g;
      };
      this.prendre_les_graines = function() {
        var main, _ref1;
        if (debug) {
          console.log("$ @prendre_les_graines : en ce moment il y a " + this.trous[this.pointeur] + " graine(s) dans le trou " + this.pointeur);
        }
        _ref1 = [this.trous[this.pointeur], 0], main = _ref1[0], this.trous[this.pointeur] = _ref1[1];
        if (this.graphique) {
          $("#" + this.pointeur).empty();
        }
        return main;
      };
      this.depose_une_graine = function() {
        this.trous[this.pointeur] += 1;
        if (this.graphique) {
          $("#" + this.pointeur).append("<div class='graine'></div>");
          return $("#" + this.pointeur + " .graine").each(function() {
            var rand;
            rand = function() {
              return 10 + Math.floor(Math.random() * 45);
            };
            return $(this).css({
              top: (rand()) + "%",
              left: (rand()) + "%",
              transform: "rotate(" + (3 * rand()) + "deg)"
            });
          });
        }
      };
      this.nourrirAdversaire = function() {
        return this.pointeur + this.trous[this.pointeur] > 6 * (this.player + 1);
      };
      this.prenable = function(origine, gain_virtuel) {
        var _ref1, _ref2;
        if (origine == null) {
          origine = this.pointeur;
        }
        if (gain_virtuel == null) {
          gain_virtuel = 0;
        }
        while (((_ref1 = this.trous[this.pointeur]) === 2 || _ref1 === 3) && (_ref2 = this.pointeur, __indexOf.call(this.camps[this.adversaire], _ref2) >= 0)) {
          gain_virtuel += this.trous[this.pointeur];
          this.trou_precedent();
        }
        this.pointeur = origine;
        return (gain_virtuel > 0) && (gain_virtuel !== this.total_graines(this.adversaire));
      };
      this.prendre = function() {
        var _ref1, _ref2, _results;
        if (debug) {
          console.log("$ @prendre() : il y a prise !");
        }
        _results = [];
        while (((_ref1 = this.trous[this.pointeur]) === 2 || _ref1 === 3) && (_ref2 = this.pointeur, __indexOf.call(this.camps[this.adversaire], _ref2) >= 0)) {
          this.score[this.player] += this.trous[this.pointeur];
          this.prendre_les_graines();
          if (this.graphique) {
            $("#score" + this.player).html(this.score[this.player]);
          }
          _results.push(this.trou_precedent());
        }
        return _results;
      };
      this.reprendre_ses_graines = function() {
        var player, trou, _j, _k, _len, _len1, _ref1, _ref2, _results;
        _ref1 = [0, 1];
        _results = [];
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          player = _ref1[_j];
          _ref2 = this.camps[player];
          for (_k = 0, _len1 = _ref2.length; _k < _len1; _k++) {
            trou = _ref2[_k];
            this.pointeur = trou;
            this.score[player] += this.trous[this.pointeur];
            this.prendre_les_graines();
          }
          if (this.graphique) {
            _results.push($("#score" + player).html(this.score[player]));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };
      this.fin_de_jeu = function() {
        var config1, config2, the_end, trou, _j, _len, _ref1;
        the_end = true;
        config1 = (this.total_graines(this.player) === 1) && (this.total_graines(this.adversaire) === 1) && ((this.trous[1] === 1) && (this.trous[7] === 1));
        config2 = (this.total_graines(this.player) === 2) && (this.total_graines(this.adversaire) === 2) && ((this.trous[1] === 1) && (this.trous[2] === 1) && (this.trous[7] === 1) && (this.trous[8] === 1));
        if (config1 || config2) {
          return the_end;
        } else {
          _ref1 = this.camps[this.player];
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            trou = _ref1[_j];
            if (this.jouable(trou)) {
              the_end = !the_end;
            }
            if (!the_end) {
              break;
            }
          }
        }
        return the_end;
      };
      this.jouable = function(_at_pointeur) {
        var _ref1;
        this.pointeur = _at_pointeur;
        if (debug) {
          console.log("$ @jouable(" + this.pointeur + ") : Ce coup est-il jouable ?");
        }
        if ((_ref1 = this.pointeur, __indexOf.call(this.camps[this.player], _ref1) >= 0) && (this.trous[this.pointeur] > 0)) {
          switch (this.total_graines(this.adversaire)) {
            case 0:
              console.log(this.nourrirAdversaire());
              return this.nourrirAdversaire();
            default:
              return true;
          }
        } else {
          return false;
        }
      };
    }

    Awale.prototype.jouer = function(_at_pointeur) {
      var main, origine;
      this.pointeur = _at_pointeur;
      if (debug) {
        console.log("joueur" + this.player + " veut jouer le trou " + this.pointeur + " dans lequel il y a " + this.trous[this.pointeur] + " graine(s)");
      }
      if (this.jouable(this.pointeur)) {
        origine = this.pointeur;
        main = this.prendre_les_graines();
        if (debug) {
          console.log("ok, c'est jouable ! le pointeur est en " + this.pointeur + ", je prend " + main + " graine(s) dans ma main.");
        }
        while (main > 0) {
          this.trou_suivant();
          if (this.pointeur !== origine) {
            this.depose_une_graine();
            main -= 1;
          }
        }
        if (this.prenable()) {
          this.prendre();
        }
        this.joueur_suivant();
        if (this.fin_de_jeu()) {
          if (this.graphique) {
            alert("jeu terminé !");
          }
          return this.reprendre_ses_graines();
        }
      } else {
        return console.log("argh, ce n'est pas jouable !");
      }
    };

    Awale.prototype.to_html = function() {
      var $awalé, j, trou, _i, _j, _ref;
      $awalé = $("<div><div id='awalé_" + this.id + "' class='awalé'><div id='camp0' class='camp'></div><div id='camp1' class='camp'></div></div></div>");
      for (trou = _i = 1; _i <= 12; trou = ++_i) {
        $awalé.find("#camp" + (trou < 7 ? 0 : 1)).append("<div id='" + trou + "' class='trou'>");
        this.pointeur = trou;
        for (j = _j = 0, _ref = this.trous[j] - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; j = 0 <= _ref ? ++_j : --_j) {
          this.depose_une_graine();
        }
      }
      return $awalé.html();
    };

    return Awale;

  })();

  $(function() {
    var aiLevel, awale, first_dblclick;
    awale = new Awale();
    $("#game").append(awale.to_html());
    awale.initialiser();
    first_dblclick = true;
    $(".trou").on("click", function() {
      var t;
      t = parseInt($(this).attr("id"));
      $(".trou").removeClass("selected");
      $(this).addClass("selected");
      return $(this).append($("#info").html(awale.trous[t]).show());
    });
    $(".trou").on("dblclick", function() {
      var t, _ref;
      t = parseInt($(this).attr("id"));
      if (first_dblclick) {
        _ref = __indexOf.call([1, 2, 3, 4, 5, 6], t) >= 0 ? [0, 1] : [1, 0], awale.player = _ref[0], awale.adversaire = _ref[1];
        $("#awalé_" + awale.id + " #camp" + awale.player).addClass("selected");
        first_dblclick = false;
      }
      $("body").append($("#info").hide());
      return awale.jouer(t);
    });
    aiLevel = 1;
    $("input[name=AIlevel]").on("click", function() {
      return aiLevel = parseInt($(this).val());
    });
    return $("#ordi").on("click", function() {
      var a, best, i, level, max, t, virtual_shot, _i, _len, _ref, _ref1;
      if (first_dblclick) {
        t = Math.floor(Math.random() * 2);
        _ref = __indexOf.call([1, 2, 3, 4, 5, 6], t) >= 0 ? [0, 1] : [1, 0], awale.player = _ref[0], awale.adversaire = _ref[1];
        $("#awalé_" + awale.id + " #camp" + awale.player).addClass("selected");
        first_dblclick = false;
      }
      max = -50;
      best = -1;
      _ref1 = awale.camps[awale.player];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        i = _ref1[_i];
        if (awale.jouable(i)) {
          best = i;
          break;
        }
      }
      if (best === -1) {
        alert("???");
      }
      level = 0;
      virtual_shot = function(awales, ai, adversaire) {
        var delta, game, index, key, new_awales, _j, _len1, _ref2, _ref3;
        new_awales = {};
        for (key in awales) {
          game = awales[key];
          _ref2 = game.camps[game.player];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            i = _ref2[_j];
            if (game.jouable(i)) {
              index = key + "#" + i + ".";
              new_awales[index] = clone(game);
              new_awales[index].graphique = false;
              new_awales[index].jouer(i);
              delta = new_awales[index].score[ai] - new_awales[index].score[adversaire];
              if (delta > max) {
                _ref3 = [delta, parseInt(index.slice(2, 4))], max = _ref3[0], best = _ref3[1];
                console.log("au niveau " + level + " je change de strategie, je vise " + new_awales[index].score[ai] + "-" + new_awales[index].score[adversaire] + " en jouant le trou " + best);
              }
            }
          }
        }
        return new_awales;
      };
      a = {
        "#": awale
      };
      while (level++ < aiLevel) {
        console.log("level " + level);
        a = virtual_shot(a, awale.player, awale.adversaire);
      }
      console.log("Je vais t'éclater en jouant le trou " + best);
      return awale.jouer(best);
    });
  });

}).call(this);
