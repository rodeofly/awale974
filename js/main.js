// Generated by CoffeeScript 1.10.0
(function() {
  var $graines, Awale, debug, unique_id,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  unique_id = 0;

  debug = false;

  $graines = 4;

  Awale = (function() {
    function Awale() {
      var i, j, ref, ref1;
      ref = [unique_id++, 0, 1, 1, 1], this.id = ref[0], this.player = ref[1], this.adversaire = ref[2], this.pointeur = ref[3], this.graphique = ref[4];
      ref1 = [
        {}, {
          0: [1, 2, 3, 4, 5, 6],
          1: [7, 8, 9, 10, 11, 12]
        }, {
          0: 0,
          1: 0
        }
      ], this.trous = ref1[0], this.camps = ref1[1], this.score = ref1[2];
      for (i = j = 1; j <= 12; i = ++j) {
        this.trous[i] = 0;
      }
      this.initialiser = function() {
        var k, results;
        results = [];
        for (i = k = 1; k <= 12; i = ++k) {
          this.pointeur = i;
          results.push((function() {
            var l, ref2, results1;
            results1 = [];
            for (l = 1, ref2 = $graines; 1 <= ref2 ? l <= ref2 : l >= ref2; 1 <= ref2 ? l++ : l--) {
              results1.push(this.depose_une_graine());
            }
            return results1;
          }).call(this));
        }
        return results;
      };
      this.joueur_suivant = function() {
        var ref2;
        ref2 = [this.adversaire, this.player], this.player = ref2[0], this.adversaire = ref2[1];
        if (this.graphique) {
          return $("#awalé_" + this.id + " .camp").toggleClass("selected");
        }
      };
      this.trou_suivant = function() {
        return this.pointeur = this.pointeur % 12 + 1;
      };
      this.trou_precedent = function() {
        return this.pointeur = this.pointeur === 1 ? 12 : this.pointeur - 1;
      };
      this.total_graines = function(joueur) {
        var g, k, len, ref2;
        g = 0;
        ref2 = this.camps[joueur];
        for (k = 0, len = ref2.length; k < len; k++) {
          i = ref2[k];
          g += this.trous[i];
        }
        return g;
      };
      this.prendre_les_graines = function() {
        var main, ref2;
        if (debug) {
          console.log("$ @prendre_les_graines : en ce moment il y a " + this.trous[this.pointeur] + " graine(s) dans le trou " + this.pointeur);
        }
        ref2 = [this.trous[this.pointeur], 0], main = ref2[0], this.trous[this.pointeur] = ref2[1];
        if (this.graphique) {
          $("#awalé_" + this.id + " #" + this.pointeur).empty();
        }
        return main;
      };
      this.depose_une_graine = function() {
        this.trous[this.pointeur] += 1;
        if (this.graphique) {
          $("#awalé_" + this.id + " #" + this.pointeur).append("<div class='graine'></div>");
          return $("#awalé_" + this.id + " #" + this.pointeur + " .graine").each(function() {
            var rand;
            rand = function() {
              return 15 + Math.floor(Math.random() * 35);
            };
            return $(this).css({
              transform: "rotate(" + (3 * rand()) + "deg)"
            }).animate({
              top: (rand()) + "%",
              left: (rand()) + "%"
            });
          });
        }
      };
      this.nourrirAdversaire = function() {
        return this.pointeur + this.trous[this.pointeur] > 6 * (this.player + 1);
      };
      this.prenable = function(origine) {
        var gain, ref2, ref3;
        if (origine == null) {
          origine = this.pointeur;
        }
        gain = 0;
        while (((ref2 = this.trous[this.pointeur]) === 2 || ref2 === 3) && (ref3 = this.pointeur, indexOf.call(this.camps[this.adversaire], ref3) >= 0)) {
          gain += this.trous[this.pointeur];
          this.trou_precedent();
        }
        this.pointeur = origine;
        return (gain > 0) && (gain !== this.total_graines(this.adversaire));
      };
      this.prendre = function() {
        var ref2, ref3, results;
        results = [];
        while (((ref2 = this.trous[this.pointeur]) === 2 || ref2 === 3) && (ref3 = this.pointeur, indexOf.call(this.camps[this.adversaire], ref3) >= 0)) {
          this.score[this.player] += this.trous[this.pointeur];
          this.prendre_les_graines();
          if (this.graphique) {
            $("#awalé_" + this.id + " #score" + this.player).html(this.score[this.player]);
          }
          results.push(this.trou_precedent());
        }
        return results;
      };
      this.reprendre_ses_graines = function() {
        var k, l, len, len1, player, ref2, ref3, results, trou;
        ref2 = [0, 1];
        results = [];
        for (k = 0, len = ref2.length; k < len; k++) {
          player = ref2[k];
          ref3 = this.camps[player];
          for (l = 0, len1 = ref3.length; l < len1; l++) {
            trou = ref3[l];
            this.pointeur = trou;
            this.score[player] += this.trous[this.pointeur];
            this.prendre_les_graines();
          }
          if (this.graphique) {
            results.push($("#score" + player).html(this.score[player]));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      this.fin_de_jeu = function() {
        var config1, config2, k, len, ref2, the_end, trou;
        the_end = true;
        config1 = (this.total_graines(this.player) === 1) && (this.total_graines(this.adversaire) === 1) && ((this.trous[1] === 1) && (this.trous[7] === 1));
        config2 = (this.total_graines(this.player) === 2) && (this.total_graines(this.adversaire) === 2) && ((this.trous[1] === 1) && (this.trous[2] === 1) && (this.trous[7] === 1) && (this.trous[8] === 1));
        if (config1 || config2) {
          return the_end;
        } else {
          ref2 = this.camps[this.player];
          for (k = 0, len = ref2.length; k < len; k++) {
            trou = ref2[k];
            if (this.jouable(trou)) {
              the_end = !the_end;
            }
            if (!the_end) {
              break;
            }
          }
        }
        return the_end;
      };
      this.jouable = function(pointeur) {
        var ref2;
        this.pointeur = pointeur;
        if (debug) {
          console.log("$ @jouable(" + this.pointeur + ") : Ce coup est-il jouable ?");
        }
        if ((ref2 = this.pointeur, indexOf.call(this.camps[this.player], ref2) >= 0) && (this.trous[this.pointeur] > 0)) {
          if (this.total_graines(this.adversaire) === 0) {
            return this.nourrirAdversaire();
          } else {
            return true;
          }
        } else {
          return false;
        }
      };
    }

    Awale.prototype.jouer = function(pointeur) {
      var main, origine;
      this.pointeur = pointeur;
      if (debug) {
        console.log("joueur" + this.player + " veut jouer le trou " + this.pointeur + " dans lequel il y a " + this.trous[this.pointeur] + " graine(s)");
      }
      if (this.jouable(this.pointeur)) {
        origine = this.pointeur;
        main = this.prendre_les_graines();
        if (debug) {
          console.log("ok, c'est jouable ! le pointeur est en " + this.pointeur + ", je prend " + main + " graine(s) dans ma main.");
        }
        while (main > 0) {
          this.trou_suivant();
          if (this.pointeur !== origine) {
            this.depose_une_graine();
            main -= 1;
          }
        }
        if (this.prenable()) {
          this.prendre();
        }
        this.joueur_suivant();
        if (this.fin_de_jeu()) {
          if (this.graphique) {
            alert("jeu terminé !");
          }
          return this.reprendre_ses_graines();
        }
      } else {
        if (debug) {
          return console.log("argh, ce n'est pas jouable !");
        }
      }
    };

    Awale.prototype.to_html = function() {
      var $awalé, html, j, k, ref, trou;
      html = "<div><div id='awalé_" + this.id + "' class='awalé'>\n    <div id='info'   class='score'></div>\n    <div id='score0' class='score'></div><div id='score1' class='score'></div>\n    <div id='camp0' class='camp'></div><div id='camp1' class='camp'></div>\n</div></div>";
      $awalé = $(html);
      for (trou = j = 1; j <= 12; trou = ++j) {
        $awalé.find("#camp" + (trou < 7 ? 0 : 1)).append("<div id='" + trou + "' class='trou'>");
        this.pointeur = trou;
        for (k = 1, ref = this.trous[trou]; 1 <= ref ? k <= ref : k >= ref; 1 <= ref ? k++ : k--) {
          this.depose_une_graine();
        }
      }
      return $awalé.html();
    };

    return Awale;

  })();

  $(function() {
    var aiLevel, awale, first_shot, on_first_shot, ref;
    awale = new Awale();
    $("#game").append(awale.to_html());
    awale.initialiser();
    ref = [1, true], aiLevel = ref[0], first_shot = ref[1];
    $("input[name=AIlevel]").on("click", function() {
      return aiLevel = parseInt($(this).val());
    });
    $(".trou").on("click", function() {
      var t;
      t = parseInt($(this).attr("id"));
      $(".trou").removeClass("selected");
      return $(this).addClass("selected").append($("#info").html(awale.trous[t]).show());
    });
    on_first_shot = function(trou) {
      var ref1;
      if (trou == null) {
        trou = Math.floor(Math.random() * 12) + 1;
      }
      ref1 = indexOf.call([1, 2, 3, 4, 5, 6], trou) >= 0 ? [0, 1] : [1, 0], awale.player = ref1[0], awale.adversaire = ref1[1];
      $("#awalé_" + awale.id + " #camp" + awale.player).addClass("selected");
      return first_shot = false;
    };
    $(".trou").on("dblclick", function() {
      var t;
      t = parseInt($(this).attr("id"));
      if (first_shot) {
        on_first_shot(t);
      }
      $("#game").append($("#info").hide());
      return awale.jouer(t);
    });
    return $("#ordi").on("click", function() {
      var a, best, i, j, len, level, max, ref1, ref2, virtual_shot;
      if (first_shot) {
        on_first_shot();
      }
      ref1 = [0, -50, -1], level = ref1[0], max = ref1[1], best = ref1[2];
      ref2 = awale.camps[awale.player];
      for (j = 0, len = ref2.length; j < len; j++) {
        i = ref2[j];
        if (awale.jouable(i)) {
          best = i;
          break;
        }
      }
      virtual_shot = function(awales, ai, adversaire) {
        var clone, delta, game, index, k, key, len1, new_awales, ref3, ref4;
        clone = function(obj) {
          var key, newInstance;
          if ((obj == null) || typeof obj !== 'object') {
            return obj;
          }
          newInstance = new obj.constructor();
          for (key in obj) {
            newInstance[key] = clone(obj[key]);
          }
          return newInstance;
        };
        new_awales = {};
        for (key in awales) {
          game = awales[key];
          ref3 = game.camps[game.player];
          for (k = 0, len1 = ref3.length; k < len1; k++) {
            i = ref3[k];
            if (game.jouable(i)) {
              index = key + "#" + i + ".";
              new_awales[index] = clone(game);
              new_awales[index].graphique = false;
              new_awales[index].jouer(i);
              delta = new_awales[index].score[ai] - new_awales[index].score[adversaire];
              if (delta > max) {
                ref4 = [delta, parseInt(index.slice(2, 4))], max = ref4[0], best = ref4[1];
                console.log("au niveau " + level + ", je vise " + new_awales[index].score[ai] + "-" + new_awales[index].score[adversaire] + " en jouant le trou " + best);
              }
            }
          }
        }
        return new_awales;
      };
      a = {
        "#": awale
      };
      while (level++ < aiLevel) {
        console.log("niveau " + level);
        a = virtual_shot(a, awale.player, awale.adversaire);
      }
      console.log("Je vais t'éclater en jouant le trou " + best);
      return awale.jouer(best);
    });
  });

}).call(this);
